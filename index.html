<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PoE2 Passive Tree - Direct Copy</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #222;
            overflow: hidden;
        }

        #tree-container {
            width: 100vw;
            height: 100vh;
        }

        /* Exact CSS from poe2db */
        svg#passive_skill_tree {
            background: #222;
            cursor: grab;
            width: 100%;
            height: 100%;
        }

        svg#passive_skill_tree:active {
            cursor: grabbing;
        }

        circle {
            stroke-width: 10;
            stroke-opacity: 1;
            fill: #000;
            cursor: pointer;
            transition: stroke-width 0.1s;
        }

        circle.normal {
            stroke: #696969;
        }

        circle.notable {
            stroke: orange;
        }

        circle.keystone {
            stroke: yellow;
        }

        circle:hover {
            stroke: #4a90e2;
            stroke-width: 12;
        }

        circle.allocated {
            fill: #d4af37;
            stroke: gold;
        }

        circle.preview {
            fill: #4a90e2;
            stroke: #6ab0f5;
            fill-opacity: 0.6;
        }

        circle.preview-remove {
            fill: #e24a4a;
            stroke: #f56a6a;
            fill-opacity: 0.6;
        }

        .node-icon {
            opacity: 0.8;
            transition: opacity 0.3s ease;
        }

        circle.allocated + .node-icon {
            opacity: 1;
        }

        circle.preview + .node-icon,
        circle.preview-remove + .node-icon {
            opacity: 0.7;
        }

        #connections line,
        #connections path {
            stroke-opacity: 0.5;
        }

        #connections line.active,
        #connections path.active {
            stroke: #d4af37;
            stroke-opacity: 0.9;
            stroke-width: 20;
        }

        #connections line.preview,
        #connections path.preview {
            stroke: #4a90e2;
            stroke-opacity: 0.7;
            stroke-width: 18;
        }

        /* Phase 1: Skill Points Overlay */
        #points-overlay {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(26, 26, 26, 0.95);
            border: 2px solid #3a3a3a;
            border-radius: 8px;
            padding: 20px;
            color: #ccc;
            min-width: 200px;
            z-index: 1000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #points-overlay h3 {
            margin: 0 0 15px 0;
            color: #d4af37;
            font-size: 18px;
            text-align: center;
        }

        .points-display {
            font-size: 28px;
            color: #d4af37;
            text-align: center;
            font-weight: bold;
            margin: 10px 0;
        }

        #points-used {
            color: #d4af37;
        }

        #points-max {
            color: #8cf;
        }

        /* Class Selection Dropdown */
        .class-selection {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #3a3a3a;
        }

        .class-selection label {
            display: block;
            color: #d4af37;
            font-size: 14px;
            margin-bottom: 8px;
            font-weight: bold;
        }

        #class-dropdown {
            width: 100%;
            background: rgba(40, 40, 40, 0.9);
            border: 2px solid #555;
            border-radius: 4px;
            padding: 8px;
            color: #d4af37;
            font-size: 14px;
            cursor: pointer;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            transition: border-color 0.3s ease;
        }

        #class-dropdown:hover {
            border-color: #d4af37;
        }

        #class-dropdown:focus {
            outline: none;
            border-color: #d4af37;
        }

        #class-dropdown option {
            background: #1a1a1a;
            color: #d4af37;
        }

        /* Build Management */
        .build-management {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #3a3a3a;
        }

        .build-management h4 {
            color: #d4af37;
            margin-bottom: 15px;
            font-size: 16px;
        }

        .build-set-selection,
        .breakpoint-selection {
            margin-bottom: 15px;
        }

        .build-set-selection label,
        .breakpoint-selection label {
            display: block;
            color: #ccc;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .build-set-selection select,
        .breakpoint-selection select {
            width: calc(100% - 110px);
            padding: 8px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            color: #d4af37;
            font-size: 13px;
            cursor: pointer;
            margin-right: 5px;
        }

        .build-set-selection button,
        .breakpoint-selection button {
            width: 30px;
            height: 30px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            color: #d4af37;
            font-size: 18px;
            cursor: pointer;
            vertical-align: middle;
            margin-right: 2px;
        }

        .build-set-selection button:hover,
        .breakpoint-selection button:hover {
            background: #3a3a3a;
            border-color: #d4af37;
        }

        #delete-set-btn,
        #delete-breakpoint-btn-quick {
            color: #ff6b6b;
            font-size: 24px;
            line-height: 1;
        }

        #delete-set-btn:hover,
        #delete-breakpoint-btn-quick:hover {
            border-color: #ff6b6b;
        }

        .build-actions {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }

        .build-actions button {
            flex: 1;
            padding: 8px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            color: #d4af37;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .build-actions button:hover {
            background: #3a3a3a;
            border-color: #d4af37;
        }

        .build-actions button:active {
            background: #1a1a1a;
        }

        /* Node Tooltip */
        #node-tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #8b7355;
            border-radius: 4px;
            padding: 12px 16px;
            color: #c8c8c8;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px;
            pointer-events: none;
            z-index: 10000;
            max-width: 350px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.8);
        }

        .tooltip-title {
            font-size: 16px;
            font-weight: bold;
            color: #ffffff;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid #555;
        }

        .tooltip-title.notable {
            color: #d4af37;
        }

        .tooltip-title.keystone {
            color: #ffd700;
        }

        .tooltip-stats {
            line-height: 1.6;
        }

        .tooltip-stats div {
            color: #8888ff;
            margin: 2px 0;
        }
    </style>
</head>
<body>
    <div id="tree-container"></div>

    <!-- Node Tooltip -->
    <div id="node-tooltip" style="display: none;">
        <div class="tooltip-title"></div>
        <div class="tooltip-stats"></div>
    </div>

    <!-- Points Counter Overlay -->
    <div id="points-overlay">
        <h3>Skill Points</h3>
        <div class="points-display">
            <span id="points-used">0</span> / <span id="points-max">123</span>
        </div>

        <!-- Class Selection Dropdown -->
        <div class="class-selection">
            <label for="class-dropdown">Starting Class</label>
            <select id="class-dropdown">
                <option value="">-- Select Class --</option>
                <option value="50986">Mercenary</option>
                <option value="54447">Sorceress</option>
                <option value="54447">Witch</option>
                <option value="50459">Ranger</option>
                <option value="50459">Huntress</option>
                <option value="47175">Warrior</option>
                <option value="44683">Monk</option>
            </select>
        </div>

        <!-- Build Management -->
        <div class="build-management">
            <h4>Build Management</h4>

            <!-- Build Set Selection -->
            <div class="build-set-selection">
                <label for="build-set-dropdown">Build Set</label>
                <select id="build-set-dropdown">
                    <option value="">-- New Build Set --</option>
                </select>
                <button id="new-set-btn" title="Create New Build Set">+</button>
                <button id="edit-set-btn" title="Edit Build Set Name">✎</button>
                <button id="delete-set-btn" title="Delete Build Set">×</button>
            </div>

            <!-- Level Breakpoint Selection -->
            <div class="breakpoint-selection">
                <label for="breakpoint-dropdown">Level Breakpoint</label>
                <select id="breakpoint-dropdown">
                    <option value="">-- Select Breakpoint --</option>
                </select>
                <button id="add-breakpoint-btn" title="Add Level Breakpoint">+</button>
                <button id="edit-breakpoint-btn" title="Edit Breakpoint Name">✎</button>
                <button id="delete-breakpoint-btn-quick" title="Delete Breakpoint">×</button>
            </div>

            <!-- Action Buttons -->
            <div class="build-actions">
                <button id="save-breakpoint-btn">Save Current</button>
                <button id="load-breakpoint-btn">Load</button>
                <button id="delete-breakpoint-btn">Delete</button>
            </div>
        </div>
    </div>

    <script>
        // Load both the SVG and the tree data
        Promise.all([
            fetch('poe2snippet.html').then(r => r.text()),
            fetch('data_us.json').then(r => r.json())
        ])
            .then(([svgContent, treeData]) => {
                document.getElementById('tree-container').innerHTML = svgContent;

                const svg = document.getElementById('passive_skill_tree');

                // Phase 1: Track allocated nodes
                let allocatedNodes = new Set();
                let startingNodeId = null; // Track the class starting node
                const maxPoints = 123;

                // Apply node images from tree data
                const nodes = treeData.nodes;
                Object.keys(nodes).forEach(nodeId => {
                    const nodeData = nodes[nodeId];
                    const circle = svg.querySelector(`#n${nodeId}`);

                    if (circle && nodeData.icon) {
                        // Create image element
                        const img = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                        const cx = parseFloat(circle.getAttribute('cx'));
                        const cy = parseFloat(circle.getAttribute('cy'));
                        const r = parseFloat(circle.getAttribute('r'));

                        // Position image centered on the circle
                        const imgSize = r * 1.5;
                        img.setAttribute('x', cx - imgSize / 2);
                        img.setAttribute('y', cy - imgSize / 2);
                        img.setAttribute('width', imgSize);
                        img.setAttribute('height', imgSize);

                        // Convert CDN URL to local PNG path with lowercase filename and subdirectory
                        const passivesPath = nodeData.icon.match(/passives\/(.+)\.webp/);
                        const skillIconPath = nodeData.icon.match(/SkillIcons\/([^/]+)\.webp/);

                        if (passivesPath) {
                            // Icons in passives/ subdirectory
                            const localPath = passivesPath[1].toLowerCase();
                            img.setAttribute('href', `images/passives/${localPath}.png`);
                        } else if (skillIconPath) {
                            // Icons in SkillIcons/ root directory
                            const filename = skillIconPath[1].toLowerCase();
                            img.setAttribute('href', `images/${filename}.png`);
                        }
                        img.setAttribute('pointer-events', 'none'); // Don't block circle clicks
                        img.classList.add('node-icon');

                        // Insert image after the circle
                        circle.parentNode.insertBefore(img, circle.nextSibling);
                    }
                });

                // Build connection graph once for performance
                const connectionGraph = new Map();
                const allConnections = svg.querySelectorAll('#connections line, #connections path');
                allConnections.forEach(conn => {
                    const connId = conn.id;
                    if (connId.startsWith('c')) {
                        const parts = connId.substring(1).split('-');
                        if (parts.length === 2) {
                            const [id1, id2] = parts;
                            // Add bidirectional connections
                            if (!connectionGraph.has(id1)) connectionGraph.set(id1, []);
                            if (!connectionGraph.has(id2)) connectionGraph.set(id2, []);
                            connectionGraph.get(id1).push(id2);
                            connectionGraph.get(id2).push(id1);
                        }
                    }
                });
                // Path validation: Find shortest path to any allocated node
                function findShortestPath(targetNodeId) {

                    // If no nodes allocated, can't path (unless it's a start node)
                    if (allocatedNodes.size === 0) {
                        // Check if it's a class start node (they can be allocated freely)
                        const targetCircle = svg.querySelector(`#n${targetNodeId}`);
                        const nodeData = targetCircle?.getAttribute('data-bs-title');
                        // Class starts typically have specific names
                        if (nodeData && (nodeData.includes('RANGER') || nodeData.includes('MARAUDER') ||
                            nodeData.includes('WITCH') || nodeData.includes('DUELIST') ||
                            nodeData.includes('TEMPLAR') || nodeData.includes('SIX') ||
                            nodeData.includes('Seven'))) {
                            return [];
                        }
                        return null; // Can't allocate if nothing allocated and not a start
                    }

                    // BFS to find shortest path
                    const queue = [];
                    const visited = new Set();
                    const parent = new Map();

                    // Start from target and search for any allocated node
                    queue.push(targetNodeId);
                    visited.add(targetNodeId);

                    while (queue.length > 0) {
                        const currentId = queue.shift();

                        // If we found an allocated node, reconstruct path
                        if (allocatedNodes.has(currentId)) {
                            const path = [];
                            let node = currentId;
                            // Reconstruct path from allocated node back to target
                            while (parent.has(node)) {
                                node = parent.get(node);
                                // Add all nodes EXCEPT the already-allocated starting point
                                if (!allocatedNodes.has(node)) {
                                    path.push(node);
                                }
                            }
                            return path; // Return intermediate nodes only
                        }

                        // Find all connected nodes using pre-built graph
                        const neighbors = connectionGraph.get(currentId) || [];
                        neighbors.forEach(neighborId => {
                            if (!visited.has(neighborId)) {
                                visited.add(neighborId);
                                parent.set(neighborId, currentId);
                                queue.push(neighborId);
                            }
                        });
                    }

                    return null; // No path found
                }

                // Find all nodes that would be disconnected if a node is removed
                function findDisconnectedNodes(removedNodeId) {
                    const disconnected = [];

                    // Check each allocated node (except starting node and the one being removed)
                    allocatedNodes.forEach(nodeId => {
                        if (nodeId === startingNodeId || nodeId === removedNodeId) return;

                        // Try to find path from this node to starting node, without using removedNodeId
                        const queue = [nodeId];
                        const visited = new Set([nodeId, removedNodeId]); // Mark removed as visited so we don't use it
                        let foundStart = false;

                        while (queue.length > 0) {
                            const currentId = queue.shift();

                            if (currentId === startingNodeId) {
                                foundStart = true;
                                break;
                            }

                            const neighbors = connectionGraph.get(currentId) || [];
                            neighbors.forEach(neighborId => {
                                // Only traverse through allocated nodes
                                if (!visited.has(neighborId) && allocatedNodes.has(neighborId)) {
                                    visited.add(neighborId);
                                    queue.push(neighborId);
                                }
                            });
                        }

                        if (!foundStart) {
                            disconnected.push(nodeId);
                        }
                    });

                    return disconnected;
                }

                // Add zoom and pan
                let zoom = 1.0;  // Start at 1x zoom (normal size)
                let panX = 0;
                let panY = 0;
                let isDragging = false;
                let lastX = 0;
                let lastY = 0;

                // Phase 1: Update points display
                function updatePointsDisplay() {
                    // Don't count the starting node
                    const pointsUsed = startingNodeId ? allocatedNodes.size - 1 : 0;
                    document.getElementById('points-used').textContent = pointsUsed;
                }

                function updateViewBox() {
                    // Start centered on the main tree area (from official site)
                    const baseViewBox = { x: -11326.103852910494, y: -11389.628444746082, width: 23256.18556701031, height: 20315.9793814433 };
                    const width = baseViewBox.width / zoom;
                    const height = baseViewBox.height / zoom;
                    const x = baseViewBox.x - panX;
                    const y = baseViewBox.y - panY;
                    svg.setAttribute('viewBox', `${x} ${y} ${width} ${height}`);
                }

                svg.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    lastX = e.clientX;
                    lastY = e.clientY;
                });

                svg.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const dx = e.clientX - lastX;
                        const dy = e.clientY - lastY;
                        // Multiply by a factor adjusted for zoom to make panning feel consistent
                        panX += dx * 50 / zoom;
                        panY += dy * 50 / zoom;

                        // Apply dynamic pan boundaries based on zoom level
                        // When zoomed in more, allow more panning to reach all areas
                        const maxPan = 30000;  // Fixed boundaries in SVG coordinates
                        panX = Math.max(-maxPan, Math.min(maxPan, panX));
                        panY = Math.max(-maxPan, Math.min(maxPan, panY));

                        lastX = e.clientX;
                        lastY = e.clientY;
                        updateViewBox();
                    }
                });

                svg.addEventListener('mouseup', () => {
                    isDragging = false;
                });

                svg.addEventListener('mouseleave', () => {
                    isDragging = false;
                });

                svg.addEventListener('wheel', (e) => {
                    e.preventDefault();

                    const oldZoom = zoom;
                    const delta = e.deltaY > 0 ? -0.1 : 0.1;  // Faster zoom
                    zoom = Math.max(0.5, Math.min(10.0, zoom + delta));  // Max zoom out: 0.5, Max zoom in: 10.0

                    // Keep pan stable relative to zoom change
                    // Don't adjust pan at all - let it stay constant

                    updateViewBox();
                });

                // Update all connection visuals
                function updateAllConnections() {
                    const allConnections = svg.querySelectorAll('#connections line, #connections path');
                    allConnections.forEach(conn => {
                        const connId = conn.id;
                        const parts = connId.replace('c', '').split('-');
                        if (parts.length === 2) {
                            const n1 = svg.querySelector(`#n${parts[0]}`);
                            const n2 = svg.querySelector(`#n${parts[1]}`);
                            if (n1 && n2 && n1.classList.contains('allocated') && n2.classList.contains('allocated')) {
                                conn.classList.add('active');
                            } else {
                                conn.classList.remove('active');
                            }
                        }
                    });
                }

                // Hover preview for path
                function clearPreview() {
                    // Clear all preview nodes
                    const previewNodes = svg.querySelectorAll('circle.preview, circle.preview-remove');
                    previewNodes.forEach(node => {
                        node.classList.remove('preview');
                        node.classList.remove('preview-remove');
                    });

                    // Clear all preview connections
                    const previewConns = svg.querySelectorAll('#connections line.preview, #connections path.preview');
                    previewConns.forEach(conn => conn.classList.remove('preview'));
                }

                function showPreview(nodeId) {
                    clearPreview();

                    if (allocatedNodes.has(nodeId)) {
                        // Show preview of nodes that will be removed (red)
                        const disconnected = findDisconnectedNodes(nodeId);

                        // Preview the node being removed
                        const targetNode = svg.querySelector(`#n${nodeId}`);
                        if (targetNode && nodeId !== startingNodeId) {
                            targetNode.classList.add('preview-remove');
                        }

                        // Preview all nodes that will be disconnected
                        disconnected.forEach(discNodeId => {
                            const discNode = svg.querySelector(`#n${discNodeId}`);
                            if (discNode) {
                                discNode.classList.add('preview-remove');
                            }
                        });
                    } else {
                        // Show preview of nodes that will be added (blue)
                        const path = findShortestPath(nodeId);

                        if (path !== null) {
                            // Preview the target node
                            const targetNode = svg.querySelector(`#n${nodeId}`);
                            if (targetNode) {
                                targetNode.classList.add('preview');
                            }

                            // Preview all intermediate nodes
                            path.forEach(pathNodeId => {
                                const pathNode = svg.querySelector(`#n${pathNodeId}`);
                                if (pathNode && !allocatedNodes.has(pathNodeId)) {
                                    pathNode.classList.add('preview');
                                }
                            });

                            // Preview connections between preview nodes
                            const previewNodeIds = new Set([nodeId, ...path]);
                            const allConnections = svg.querySelectorAll('#connections line, #connections path');
                            allConnections.forEach(conn => {
                                const connId = conn.id;
                                if (connId.startsWith('c')) {
                                    const parts = connId.substring(1).split('-');
                                    if (parts.length === 2) {
                                        const [id1, id2] = parts;
                                        // Show preview if both nodes are in preview set or one is allocated and one is preview
                                        if ((previewNodeIds.has(id1) || allocatedNodes.has(id1)) &&
                                            (previewNodeIds.has(id2) || allocatedNodes.has(id2))) {
                                            conn.classList.add('preview');
                                        }
                                    }
                                }
                            });
                        }
                    }
                }

                svg.addEventListener('mouseover', (e) => {
                    if (e.target.tagName === 'circle') {
                        const nodeId = e.target.id.replace('n', '');
                        showPreview(nodeId);
                    }
                });

                svg.addEventListener('mouseout', (e) => {
                    if (e.target.tagName === 'circle') {
                        clearPreview();
                    }
                });

                // Add click to allocate with path validation
                svg.addEventListener('click', (e) => {
                    if (e.target.tagName === 'circle') {
                        const nodeId = e.target.id.replace('n', '');

                        if (e.target.classList.contains('allocated')) {
                            // Can't remove the starting node
                            if (nodeId === startingNodeId) return;

                            // Find nodes that will be disconnected
                            const disconnected = findDisconnectedNodes(nodeId);

                            // Deallocate the clicked node
                            e.target.classList.remove('allocated');
                            allocatedNodes.delete(nodeId);

                            // Deallocate all disconnected nodes
                            disconnected.forEach(discNodeId => {
                                const discNode = svg.querySelector(`#n${discNodeId}`);
                                if (discNode) {
                                    discNode.classList.remove('allocated');
                                    allocatedNodes.delete(discNodeId);
                                }
                            });
                        } else {
                            // Try to allocate with path finding
                            const path = findShortestPath(nodeId);

                            if (path !== null) {
                                // Allocate the target node
                                e.target.classList.add('allocated');
                                allocatedNodes.add(nodeId);

                                // Allocate all nodes in the path
                                path.forEach(pathNodeId => {
                                    const pathNode = svg.querySelector(`#n${pathNodeId}`);
                                    if (pathNode && !allocatedNodes.has(pathNodeId)) {
                                        pathNode.classList.add('allocated');
                                        allocatedNodes.add(pathNodeId);
                                    }
                                });
                            }
                        }

                        // Update points display
                        updatePointsDisplay();

                        // Update all connections
                        updateAllConnections();
                    }
                });

                // Tooltip hover logic
                const tooltip = document.getElementById('node-tooltip');
                const tooltipTitle = tooltip.querySelector('.tooltip-title');
                const tooltipStats = tooltip.querySelector('.tooltip-stats');

                svg.addEventListener('mousemove', (e) => {
                    if (e.target.tagName === 'circle' && e.target.id.startsWith('n')) {
                        const nodeId = e.target.id.replace('n', '');
                        const nodeData = nodes[nodeId];

                        if (nodeData) {
                            // Set tooltip title
                            tooltipTitle.textContent = nodeData.name || 'Unknown Node';
                            tooltipTitle.className = 'tooltip-title';

                            if (nodeData.isKeystone) {
                                tooltipTitle.classList.add('keystone');
                            } else if (nodeData.isNotable) {
                                tooltipTitle.classList.add('notable');
                            }

                            // Set tooltip stats
                            if (nodeData.stats && nodeData.stats.length > 0) {
                                tooltipStats.innerHTML = nodeData.stats.map(stat =>
                                    `<div>${stat}</div>`
                                ).join('');
                            } else {
                                tooltipStats.innerHTML = '<div style="color: #888; font-style: italic;">No stats</div>';
                            }

                            // Position tooltip near the mouse
                            tooltip.style.left = (e.clientX + 15) + 'px';
                            tooltip.style.top = (e.clientY + 15) + 'px';
                            tooltip.style.display = 'block';
                        }
                    } else {
                        tooltip.style.display = 'none';
                    }
                });

                svg.addEventListener('mouseleave', () => {
                    tooltip.style.display = 'none';
                });

                // Class selection dropdown logic
                const classDropdown = document.getElementById('class-dropdown');

                classDropdown.addEventListener('change', (e) => {
                    const nodeId = e.target.value;

                    if (!nodeId) return; // No class selected

                    // Clear all allocated nodes
                    allocatedNodes.forEach(id => {
                        const node = svg.querySelector(`#n${id}`);
                        if (node) {
                            node.classList.remove('allocated');
                        }
                    });
                    allocatedNodes.clear();

                    // Clear all active connections
                    const allConnections = svg.querySelectorAll('#connections line, #connections path');
                    allConnections.forEach(conn => conn.classList.remove('active'));

                    // Allocate the selected class starting node
                    const startingNode = svg.querySelector(`#n${nodeId}`);
                    if (startingNode) {
                        startingNode.classList.add('allocated');
                        allocatedNodes.add(nodeId);
                        startingNodeId = nodeId; // Track the starting node
                        updatePointsDisplay();
                    }
                });

                // Build Management System
                let buildSets = JSON.parse(localStorage.getItem('poe2_build_sets') || '{}');
                let currentSetId = null;
                let currentBreakpointId = null;

                const buildSetDropdown = document.getElementById('build-set-dropdown');
                const breakpointDropdown = document.getElementById('breakpoint-dropdown');
                const newSetBtn = document.getElementById('new-set-btn');
                const editSetBtn = document.getElementById('edit-set-btn');
                const deleteSetBtn = document.getElementById('delete-set-btn');
                const addBreakpointBtn = document.getElementById('add-breakpoint-btn');
                const editBreakpointBtn = document.getElementById('edit-breakpoint-btn');
                const deleteBreakpointBtnQuick = document.getElementById('delete-breakpoint-btn-quick');
                const saveBreakpointBtn = document.getElementById('save-breakpoint-btn');
                const loadBreakpointBtn = document.getElementById('load-breakpoint-btn');
                const deleteBreakpointBtn = document.getElementById('delete-breakpoint-btn');

                // Load build sets into dropdown
                function refreshBuildSetDropdown() {
                    buildSetDropdown.innerHTML = '<option value="">-- New Build Set --</option>';
                    Object.keys(buildSets).forEach(setId => {
                        const option = document.createElement('option');
                        option.value = setId;
                        option.textContent = buildSets[setId].name;
                        buildSetDropdown.appendChild(option);
                    });
                }

                // Load breakpoints for current set
                function refreshBreakpointDropdown() {
                    breakpointDropdown.innerHTML = '<option value="">-- Select Breakpoint --</option>';
                    if (currentSetId && buildSets[currentSetId]) {
                        const breakpoints = buildSets[currentSetId].breakpoints || {};
                        Object.keys(breakpoints).forEach(bpId => {
                            const bp = breakpoints[bpId];
                            const option = document.createElement('option');
                            option.value = bpId;
                            option.textContent = `${bp.name} (${bp.points} points)`;
                            breakpointDropdown.appendChild(option);
                        });
                    }
                }

                // Save to localStorage
                function saveBuildSets() {
                    localStorage.setItem('poe2_build_sets', JSON.stringify(buildSets));
                }

                // Create new build set
                newSetBtn.addEventListener('click', () => {
                    const name = prompt('Enter build set name:');
                    if (name) {
                        const setId = 'set_' + Date.now();
                        buildSets[setId] = {
                            name: name,
                            breakpoints: {}
                        };
                        currentSetId = setId;
                        saveBuildSets();
                        refreshBuildSetDropdown();
                        buildSetDropdown.value = setId;
                        refreshBreakpointDropdown();
                    }
                });

                // Edit build set name
                editSetBtn.addEventListener('click', () => {
                    if (!currentSetId) {
                        alert('Please select a build set first.');
                        return;
                    }
                    const currentName = buildSets[currentSetId].name;
                    const newName = prompt('Enter new name for build set:', currentName);
                    if (newName && newName !== currentName) {
                        buildSets[currentSetId].name = newName;
                        saveBuildSets();
                        refreshBuildSetDropdown();
                        buildSetDropdown.value = currentSetId;
                    }
                });

                // Delete build set
                deleteSetBtn.addEventListener('click', () => {
                    if (!currentSetId) {
                        alert('Please select a build set to delete.');
                        return;
                    }
                    const setName = buildSets[currentSetId].name;
                    if (confirm(`Are you sure you want to delete the build set "${setName}" and all its breakpoints?`)) {
                        delete buildSets[currentSetId];
                        currentSetId = null;
                        currentBreakpointId = null;
                        saveBuildSets();
                        refreshBuildSetDropdown();
                        refreshBreakpointDropdown();
                        buildSetDropdown.value = '';
                        breakpointDropdown.value = '';
                    }
                });

                // Switch build set
                buildSetDropdown.addEventListener('change', (e) => {
                    currentSetId = e.target.value || null;
                    currentBreakpointId = null;
                    breakpointDropdown.value = '';
                    refreshBreakpointDropdown();
                });

                // Add new breakpoint
                addBreakpointBtn.addEventListener('click', () => {
                    if (!currentSetId) {
                        alert('Please select or create a build set first.');
                        return;
                    }
                    const name = prompt('Enter name for this breakpoint (e.g., "Level 15 - Basic Setup", "Endgame"):');
                    if (name) {
                        const bpId = 'bp_' + Date.now();
                        const pointsUsed = startingNodeId ? allocatedNodes.size - 1 : 0;
                        buildSets[currentSetId].breakpoints[bpId] = {
                            name: name,
                            points: pointsUsed,
                            allocatedNodes: Array.from(allocatedNodes),
                            startingNode: startingNodeId,
                            selectedClass: classDropdown.value
                        };
                        currentBreakpointId = bpId;
                        saveBuildSets();
                        refreshBreakpointDropdown();
                        breakpointDropdown.value = bpId;
                    }
                });

                // Edit breakpoint name
                editBreakpointBtn.addEventListener('click', () => {
                    const selectedBp = breakpointDropdown.value;
                    if (!selectedBp) {
                        alert('Please select a breakpoint first.');
                        return;
                    }
                    const currentName = buildSets[currentSetId].breakpoints[selectedBp].name;
                    const newName = prompt('Enter new name for breakpoint:', currentName);
                    if (newName && newName !== currentName) {
                        buildSets[currentSetId].breakpoints[selectedBp].name = newName;
                        saveBuildSets();
                        refreshBreakpointDropdown();
                        breakpointDropdown.value = selectedBp;
                    }
                });

                // Delete breakpoint (quick button)
                deleteBreakpointBtnQuick.addEventListener('click', () => {
                    const selectedBp = breakpointDropdown.value;
                    if (!selectedBp) {
                        alert('Please select a breakpoint to delete.');
                        return;
                    }
                    const bpName = buildSets[currentSetId].breakpoints[selectedBp].name;
                    if (confirm(`Are you sure you want to delete the breakpoint "${bpName}"?`)) {
                        delete buildSets[currentSetId].breakpoints[selectedBp];
                        currentBreakpointId = null;
                        saveBuildSets();
                        refreshBreakpointDropdown();
                        breakpointDropdown.value = '';
                    }
                });

                // Save current tree to breakpoint
                saveBreakpointBtn.addEventListener('click', () => {
                    if (!currentBreakpointId) {
                        alert('Please select a breakpoint first.');
                        return;
                    }
                    const pointsUsed = startingNodeId ? allocatedNodes.size - 1 : 0;
                    buildSets[currentSetId].breakpoints[currentBreakpointId].allocatedNodes = Array.from(allocatedNodes);
                    buildSets[currentSetId].breakpoints[currentBreakpointId].points = pointsUsed;
                    buildSets[currentSetId].breakpoints[currentBreakpointId].startingNode = startingNodeId;
                    buildSets[currentSetId].breakpoints[currentBreakpointId].selectedClass = classDropdown.value;
                    saveBuildSets();
                    refreshBreakpointDropdown();
                    alert('Breakpoint saved!');
                });

                // Load breakpoint
                loadBreakpointBtn.addEventListener('click', () => {
                    const selectedBp = breakpointDropdown.value;
                    if (!selectedBp) {
                        alert('Please select a breakpoint to load.');
                        return;
                    }
                    currentBreakpointId = selectedBp;
                    const bp = buildSets[currentSetId].breakpoints[selectedBp];

                    // Clear current tree
                    allocatedNodes.forEach(id => {
                        const node = svg.querySelector(`#n${id}`);
                        if (node) node.classList.remove('allocated');
                    });
                    allocatedNodes.clear();

                    // Clear connections
                    const allConnections = svg.querySelectorAll('#connections line, #connections path');
                    allConnections.forEach(conn => conn.classList.remove('active'));

                    // Set the starting node first
                    startingNodeId = bp.startingNode;

                    // Load breakpoint nodes
                    bp.allocatedNodes.forEach(id => {
                        const node = svg.querySelector(`#n${id}`);
                        if (node) {
                            node.classList.add('allocated');
                            allocatedNodes.add(id);
                        }
                    });

                    // Update class dropdown (this should reflect the saved class)
                    classDropdown.value = bp.selectedClass || '';

                    updateAllConnections();
                    updatePointsDisplay();
                });

                // Delete breakpoint
                deleteBreakpointBtn.addEventListener('click', () => {
                    const selectedBp = breakpointDropdown.value;
                    if (!selectedBp) {
                        alert('Please select a breakpoint to delete.');
                        return;
                    }
                    if (confirm('Are you sure you want to delete this breakpoint?')) {
                        delete buildSets[currentSetId].breakpoints[selectedBp];
                        currentBreakpointId = null;
                        saveBuildSets();
                        refreshBreakpointDropdown();
                        breakpointDropdown.value = '';
                    }
                });

                // Switch breakpoint
                breakpointDropdown.addEventListener('change', (e) => {
                    currentBreakpointId = e.target.value || null;
                });

                // Initialize
                refreshBuildSetDropdown();

                updateViewBox();
            })
            .catch(err => {
                console.error('Failed to load SVG:', err);
                document.getElementById('tree-container').innerHTML = '<div style="color: white; padding: 20px;">Failed to load tree. Make sure poe2snippet.html exists.</div>';
            });
    </script>
</body>
</html>
