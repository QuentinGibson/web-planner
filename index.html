<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PoE2 Passive Tree - Direct Copy</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #222;
            overflow: hidden;
        }

        #tree-container {
            width: 100vw;
            height: 100vh;
        }

        /* Exact CSS from poe2db */
        svg#passive_skill_tree {
            background: #222;
            cursor: grab;
            width: 100%;
            height: 100%;
        }

        svg#passive_skill_tree:active {
            cursor: grabbing;
        }

        circle {
            stroke-width: 10;
            stroke-opacity: 1;
            fill: #000;
            cursor: pointer;
            transition: stroke-width 0.1s;
        }

        circle.normal {
            stroke: #696969;
        }

        circle.notable {
            stroke: orange;
        }

        circle.keystone {
            stroke: yellow;
        }

        circle:hover {
            stroke: #4a90e2;
            stroke-width: 12;
        }

        circle.allocated {
            fill: #d4af37;
            stroke: gold;
        }

        circle.preview {
            fill: #4a90e2;
            stroke: #6ab0f5;
            fill-opacity: 0.6;
        }

        circle.preview-remove {
            fill: #e24a4a;
            stroke: #f56a6a;
            fill-opacity: 0.6;
        }

        .node-icon {
            opacity: 0.8;
            transition: opacity 0.3s ease;
        }

        circle.allocated + .node-icon {
            opacity: 1;
        }

        circle.preview + .node-icon,
        circle.preview-remove + .node-icon {
            opacity: 0.7;
        }

        #connections line,
        #connections path {
            stroke-opacity: 0.5;
        }

        #connections line.active,
        #connections path.active {
            stroke: #d4af37;
            stroke-opacity: 0.9;
            stroke-width: 20;
        }

        #connections line.preview,
        #connections path.preview {
            stroke: #4a90e2;
            stroke-opacity: 0.7;
            stroke-width: 18;
        }

        /* Phase 1: Skill Points Overlay */
        #points-overlay {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(26, 26, 26, 0.95);
            border: 2px solid #3a3a3a;
            border-radius: 8px;
            padding: 20px;
            color: #ccc;
            min-width: 200px;
            z-index: 1000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #points-overlay h3 {
            margin: 0 0 15px 0;
            color: #d4af37;
            font-size: 18px;
            text-align: center;
        }

        .points-display {
            font-size: 28px;
            color: #d4af37;
            text-align: center;
            font-weight: bold;
            margin: 10px 0;
        }

        #points-used {
            color: #d4af37;
        }

        #points-max {
            color: #8cf;
        }

        /* Class Selection Dropdown */
        .class-selection {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #3a3a3a;
        }

        .class-selection label {
            display: block;
            color: #d4af37;
            font-size: 14px;
            margin-bottom: 8px;
            font-weight: bold;
        }

        #class-dropdown {
            width: 100%;
            background: rgba(40, 40, 40, 0.9);
            border: 2px solid #555;
            border-radius: 4px;
            padding: 8px;
            color: #d4af37;
            font-size: 14px;
            cursor: pointer;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            transition: border-color 0.3s ease;
        }

        #class-dropdown:hover {
            border-color: #d4af37;
        }

        #class-dropdown:focus {
            outline: none;
            border-color: #d4af37;
        }

        #class-dropdown option {
            background: #1a1a1a;
            color: #d4af37;
        }
    </style>
</head>
<body>
    <div id="tree-container"></div>

    <!-- Points Counter Overlay -->
    <div id="points-overlay">
        <h3>Skill Points</h3>
        <div class="points-display">
            <span id="points-used">0</span> / <span id="points-max">123</span>
        </div>

        <!-- Class Selection Dropdown -->
        <div class="class-selection">
            <label for="class-dropdown">Starting Class</label>
            <select id="class-dropdown">
                <option value="">-- Select Class --</option>
                <option value="50986">Mercenary</option>
                <option value="54447">Sorceress</option>
                <option value="50459">Huntress</option>
                <option value="47175">Warrior</option>
                <option value="44683">Monk</option>
            </select>
        </div>
    </div>

    <script>
        // Load both the SVG and the tree data
        Promise.all([
            fetch('poe2snippet.html').then(r => r.text()),
            fetch('data_us.json').then(r => r.json())
        ])
            .then(([svgContent, treeData]) => {
                document.getElementById('tree-container').innerHTML = svgContent;

                const svg = document.getElementById('passive_skill_tree');

                // Phase 1: Track allocated nodes
                let allocatedNodes = new Set();
                let startingNodeId = null; // Track the class starting node
                const maxPoints = 123;

                // Apply node images from tree data
                const nodes = treeData.nodes;
                Object.keys(nodes).forEach(nodeId => {
                    const nodeData = nodes[nodeId];
                    const circle = svg.querySelector(`#n${nodeId}`);

                    if (circle && nodeData.icon) {
                        // Create image element
                        const img = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                        const cx = parseFloat(circle.getAttribute('cx'));
                        const cy = parseFloat(circle.getAttribute('cy'));
                        const r = parseFloat(circle.getAttribute('r'));

                        // Position image centered on the circle
                        const imgSize = r * 1.5;
                        img.setAttribute('x', cx - imgSize / 2);
                        img.setAttribute('y', cy - imgSize / 2);
                        img.setAttribute('width', imgSize);
                        img.setAttribute('height', imgSize);

                        // Convert CDN URL to local PNG path with lowercase filename
                        const filename = nodeData.icon.split('/').pop().replace('.webp', '').toLowerCase();
                        img.setAttribute('href', `images/passives/${filename}.png`);
                        img.setAttribute('pointer-events', 'none'); // Don't block circle clicks
                        img.classList.add('node-icon');

                        // Insert image after the circle
                        circle.parentNode.insertBefore(img, circle.nextSibling);
                    }
                });

                // Build connection graph once for performance
                const connectionGraph = new Map();
                const allConnections = svg.querySelectorAll('#connections line, #connections path');
                allConnections.forEach(conn => {
                    const connId = conn.id;
                    if (connId.startsWith('c')) {
                        const parts = connId.substring(1).split('-');
                        if (parts.length === 2) {
                            const [id1, id2] = parts;
                            // Add bidirectional connections
                            if (!connectionGraph.has(id1)) connectionGraph.set(id1, []);
                            if (!connectionGraph.has(id2)) connectionGraph.set(id2, []);
                            connectionGraph.get(id1).push(id2);
                            connectionGraph.get(id2).push(id1);
                        }
                    }
                });
                // Path validation: Find shortest path to any allocated node
                function findShortestPath(targetNodeId) {

                    // If no nodes allocated, can't path (unless it's a start node)
                    if (allocatedNodes.size === 0) {
                        // Check if it's a class start node (they can be allocated freely)
                        const targetCircle = svg.querySelector(`#n${targetNodeId}`);
                        const nodeData = targetCircle?.getAttribute('data-bs-title');
                        // Class starts typically have specific names
                        if (nodeData && (nodeData.includes('RANGER') || nodeData.includes('MARAUDER') ||
                            nodeData.includes('WITCH') || nodeData.includes('DUELIST') ||
                            nodeData.includes('TEMPLAR') || nodeData.includes('SIX') ||
                            nodeData.includes('Seven'))) {
                            return [];
                        }
                        return null; // Can't allocate if nothing allocated and not a start
                    }

                    // BFS to find shortest path
                    const queue = [];
                    const visited = new Set();
                    const parent = new Map();

                    // Start from target and search for any allocated node
                    queue.push(targetNodeId);
                    visited.add(targetNodeId);

                    while (queue.length > 0) {
                        const currentId = queue.shift();

                        // If we found an allocated node, reconstruct path
                        if (allocatedNodes.has(currentId)) {
                            const path = [];
                            let node = currentId;
                            // Reconstruct path from allocated node back to target
                            while (parent.has(node)) {
                                node = parent.get(node);
                                // Add all nodes EXCEPT the already-allocated starting point
                                if (!allocatedNodes.has(node)) {
                                    path.push(node);
                                }
                            }
                            return path; // Return intermediate nodes only
                        }

                        // Find all connected nodes using pre-built graph
                        const neighbors = connectionGraph.get(currentId) || [];
                        neighbors.forEach(neighborId => {
                            if (!visited.has(neighborId)) {
                                visited.add(neighborId);
                                parent.set(neighborId, currentId);
                                queue.push(neighborId);
                            }
                        });
                    }

                    return null; // No path found
                }

                // Find all nodes that would be disconnected if a node is removed
                function findDisconnectedNodes(removedNodeId) {
                    const disconnected = [];

                    // Check each allocated node (except starting node and the one being removed)
                    allocatedNodes.forEach(nodeId => {
                        if (nodeId === startingNodeId || nodeId === removedNodeId) return;

                        // Try to find path from this node to starting node, without using removedNodeId
                        const queue = [nodeId];
                        const visited = new Set([nodeId, removedNodeId]); // Mark removed as visited so we don't use it
                        let foundStart = false;

                        while (queue.length > 0) {
                            const currentId = queue.shift();

                            if (currentId === startingNodeId) {
                                foundStart = true;
                                break;
                            }

                            const neighbors = connectionGraph.get(currentId) || [];
                            neighbors.forEach(neighborId => {
                                // Only traverse through allocated nodes
                                if (!visited.has(neighborId) && allocatedNodes.has(neighborId)) {
                                    visited.add(neighborId);
                                    queue.push(neighborId);
                                }
                            });
                        }

                        if (!foundStart) {
                            disconnected.push(nodeId);
                        }
                    });

                    return disconnected;
                }

                // Add zoom and pan
                let zoom = 1.0;  // Start at 1x zoom (normal size)
                let panX = 0;
                let panY = 0;
                let isDragging = false;
                let lastX = 0;
                let lastY = 0;

                // Phase 1: Update points display
                function updatePointsDisplay() {
                    // Don't count the starting node
                    const pointsUsed = startingNodeId ? allocatedNodes.size - 1 : 0;
                    document.getElementById('points-used').textContent = pointsUsed;
                }

                function updateViewBox() {
                    // Start centered on the main tree area (from official site)
                    const baseViewBox = { x: -11326.103852910494, y: -11389.628444746082, width: 23256.18556701031, height: 20315.9793814433 };
                    const width = baseViewBox.width / zoom;
                    const height = baseViewBox.height / zoom;
                    const x = baseViewBox.x - panX / zoom;
                    const y = baseViewBox.y - panY / zoom;
                    svg.setAttribute('viewBox', `${x} ${y} ${width} ${height}`);
                }

                svg.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    lastX = e.clientX;
                    lastY = e.clientY;
                });

                svg.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const dx = e.clientX - lastX;
                        const dy = e.clientY - lastY;
                        // Multiply by a factor to make panning faster and more responsive
                        panX += dx * 50;
                        panY += dy * 50;
                        lastX = e.clientX;
                        lastY = e.clientY;
                        updateViewBox();
                    }
                });

                svg.addEventListener('mouseup', () => {
                    isDragging = false;
                });

                svg.addEventListener('mouseleave', () => {
                    isDragging = false;
                });

                svg.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? -0.1 : 0.1;  // Faster zoom
                    zoom = Math.max(0.1, Math.min(5.0, zoom + delta));
                    updateViewBox();
                });

                // Update all connection visuals
                function updateAllConnections() {
                    const allConnections = svg.querySelectorAll('#connections line, #connections path');
                    allConnections.forEach(conn => {
                        const connId = conn.id;
                        const parts = connId.replace('c', '').split('-');
                        if (parts.length === 2) {
                            const n1 = svg.querySelector(`#n${parts[0]}`);
                            const n2 = svg.querySelector(`#n${parts[1]}`);
                            if (n1 && n2 && n1.classList.contains('allocated') && n2.classList.contains('allocated')) {
                                conn.classList.add('active');
                            } else {
                                conn.classList.remove('active');
                            }
                        }
                    });
                }

                // Hover preview for path
                function clearPreview() {
                    // Clear all preview nodes
                    const previewNodes = svg.querySelectorAll('circle.preview, circle.preview-remove');
                    previewNodes.forEach(node => {
                        node.classList.remove('preview');
                        node.classList.remove('preview-remove');
                    });

                    // Clear all preview connections
                    const previewConns = svg.querySelectorAll('#connections line.preview, #connections path.preview');
                    previewConns.forEach(conn => conn.classList.remove('preview'));
                }

                function showPreview(nodeId) {
                    clearPreview();

                    if (allocatedNodes.has(nodeId)) {
                        // Show preview of nodes that will be removed (red)
                        const disconnected = findDisconnectedNodes(nodeId);

                        // Preview the node being removed
                        const targetNode = svg.querySelector(`#n${nodeId}`);
                        if (targetNode && nodeId !== startingNodeId) {
                            targetNode.classList.add('preview-remove');
                        }

                        // Preview all nodes that will be disconnected
                        disconnected.forEach(discNodeId => {
                            const discNode = svg.querySelector(`#n${discNodeId}`);
                            if (discNode) {
                                discNode.classList.add('preview-remove');
                            }
                        });
                    } else {
                        // Show preview of nodes that will be added (blue)
                        const path = findShortestPath(nodeId);

                        if (path !== null) {
                            // Preview the target node
                            const targetNode = svg.querySelector(`#n${nodeId}`);
                            if (targetNode) {
                                targetNode.classList.add('preview');
                            }

                            // Preview all intermediate nodes
                            path.forEach(pathNodeId => {
                                const pathNode = svg.querySelector(`#n${pathNodeId}`);
                                if (pathNode && !allocatedNodes.has(pathNodeId)) {
                                    pathNode.classList.add('preview');
                                }
                            });

                            // Preview connections between preview nodes
                            const previewNodeIds = new Set([nodeId, ...path]);
                            const allConnections = svg.querySelectorAll('#connections line, #connections path');
                            allConnections.forEach(conn => {
                                const connId = conn.id;
                                if (connId.startsWith('c')) {
                                    const parts = connId.substring(1).split('-');
                                    if (parts.length === 2) {
                                        const [id1, id2] = parts;
                                        // Show preview if both nodes are in preview set or one is allocated and one is preview
                                        if ((previewNodeIds.has(id1) || allocatedNodes.has(id1)) &&
                                            (previewNodeIds.has(id2) || allocatedNodes.has(id2))) {
                                            conn.classList.add('preview');
                                        }
                                    }
                                }
                            });
                        }
                    }
                }

                svg.addEventListener('mouseover', (e) => {
                    if (e.target.tagName === 'circle') {
                        const nodeId = e.target.id.replace('n', '');
                        showPreview(nodeId);
                    }
                });

                svg.addEventListener('mouseout', (e) => {
                    if (e.target.tagName === 'circle') {
                        clearPreview();
                    }
                });

                // Add click to allocate with path validation
                svg.addEventListener('click', (e) => {
                    if (e.target.tagName === 'circle') {
                        const nodeId = e.target.id.replace('n', '');

                        if (e.target.classList.contains('allocated')) {
                            // Can't remove the starting node
                            if (nodeId === startingNodeId) return;

                            // Find nodes that will be disconnected
                            const disconnected = findDisconnectedNodes(nodeId);

                            // Deallocate the clicked node
                            e.target.classList.remove('allocated');
                            allocatedNodes.delete(nodeId);

                            // Deallocate all disconnected nodes
                            disconnected.forEach(discNodeId => {
                                const discNode = svg.querySelector(`#n${discNodeId}`);
                                if (discNode) {
                                    discNode.classList.remove('allocated');
                                    allocatedNodes.delete(discNodeId);
                                }
                            });
                        } else {
                            // Try to allocate with path finding
                            const path = findShortestPath(nodeId);

                            if (path !== null) {
                                // Allocate the target node
                                e.target.classList.add('allocated');
                                allocatedNodes.add(nodeId);

                                // Allocate all nodes in the path
                                path.forEach(pathNodeId => {
                                    const pathNode = svg.querySelector(`#n${pathNodeId}`);
                                    if (pathNode && !allocatedNodes.has(pathNodeId)) {
                                        pathNode.classList.add('allocated');
                                        allocatedNodes.add(pathNodeId);
                                    }
                                });
                            }
                        }

                        // Update points display
                        updatePointsDisplay();

                        // Update all connections
                        updateAllConnections();
                    }
                });

                // Class selection dropdown logic
                const classDropdown = document.getElementById('class-dropdown');

                classDropdown.addEventListener('change', (e) => {
                    const nodeId = e.target.value;

                    if (!nodeId) return; // No class selected

                    // Clear all allocated nodes
                    allocatedNodes.forEach(id => {
                        const node = svg.querySelector(`#n${id}`);
                        if (node) {
                            node.classList.remove('allocated');
                        }
                    });
                    allocatedNodes.clear();

                    // Clear all active connections
                    const allConnections = svg.querySelectorAll('#connections line, #connections path');
                    allConnections.forEach(conn => conn.classList.remove('active'));

                    // Allocate the selected class starting node
                    const startingNode = svg.querySelector(`#n${nodeId}`);
                    if (startingNode) {
                        startingNode.classList.add('allocated');
                        allocatedNodes.add(nodeId);
                        startingNodeId = nodeId; // Track the starting node
                        updatePointsDisplay();
                    }
                });

                updateViewBox();
            })
            .catch(err => {
                console.error('Failed to load SVG:', err);
                document.getElementById('tree-container').innerHTML = '<div style="color: white; padding: 20px;">Failed to load tree. Make sure poe2snippet.html exists.</div>';
            });
    </script>
</body>
</html>
