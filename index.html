<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PoE2 Passive Tree - Direct Copy</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #222;
            overflow: hidden;
        }

        #tree-container {
            width: 100vw;
            height: 100vh;
        }

        /* Exact CSS from poe2db */
        svg#passive_skill_tree {
            background: #222;
            cursor: grab;
            width: 100%;
            height: 100%;
        }

        svg#passive_skill_tree:active {
            cursor: grabbing;
        }

        circle {
            stroke-width: 10;
            stroke-opacity: 1;
            fill: #000;
            cursor: pointer;
            transition: stroke-width 0.1s;
        }

        circle.normal {
            stroke: #696969;
        }

        circle.notable {
            stroke: orange;
        }

        circle.keystone {
            stroke: yellow;
        }

        circle:hover {
            stroke: #4a90e2;
            stroke-width: 12;
        }

        circle.allocated {
            fill: #d4af37;
            stroke: gold;
        }

        #connections line,
        #connections path {
            stroke-opacity: 0.5;
        }

        #connections line.active,
        #connections path.active {
            stroke: #d4af37;
            stroke-opacity: 0.9;
            stroke-width: 20;
        }

        /* Phase 1: Skill Points Overlay */
        #points-overlay {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(26, 26, 26, 0.95);
            border: 2px solid #3a3a3a;
            border-radius: 8px;
            padding: 20px;
            color: #ccc;
            min-width: 200px;
            z-index: 1000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #points-overlay h3 {
            margin: 0 0 15px 0;
            color: #d4af37;
            font-size: 18px;
            text-align: center;
        }

        .points-display {
            font-size: 28px;
            color: #d4af37;
            text-align: center;
            font-weight: bold;
            margin: 10px 0;
        }

        #points-used {
            color: #d4af37;
        }

        #points-max {
            color: #8cf;
        }

        /* Class Selection Dropdown */
        .class-selection {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #3a3a3a;
        }

        .class-selection label {
            display: block;
            color: #d4af37;
            font-size: 14px;
            margin-bottom: 8px;
            font-weight: bold;
        }

        #class-dropdown {
            width: 100%;
            background: rgba(40, 40, 40, 0.9);
            border: 2px solid #555;
            border-radius: 4px;
            padding: 8px;
            color: #d4af37;
            font-size: 14px;
            cursor: pointer;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            transition: border-color 0.3s ease;
        }

        #class-dropdown:hover {
            border-color: #d4af37;
        }

        #class-dropdown:focus {
            outline: none;
            border-color: #d4af37;
        }

        #class-dropdown option {
            background: #1a1a1a;
            color: #d4af37;
        }
    </style>
</head>
<body>
    <div id="tree-container"></div>

    <!-- Points Counter Overlay -->
    <div id="points-overlay">
        <h3>Skill Points</h3>
        <div class="points-display">
            <span id="points-used">0</span> / <span id="points-max">123</span>
        </div>

        <!-- Class Selection Dropdown -->
        <div class="class-selection">
            <label for="class-dropdown">Starting Class</label>
            <select id="class-dropdown">
                <option value="">-- Select Class --</option>
                <option value="50986">Mercenary</option>
                <option value="54447">Sorceress</option>
                <option value="50459">Huntress</option>
                <option value="47175">Warrior</option>
                <option value="44683">Monk</option>
            </select>
        </div>
    </div>

    <script>
        // Load the actual SVG snippet
        fetch('poe2snippet.html')
            .then(response => response.text())
            .then(svgContent => {
                document.getElementById('tree-container').innerHTML = svgContent;

                const svg = document.getElementById('passive_skill_tree');

                // Phase 1: Track allocated nodes
                let allocatedNodes = new Set();
                const maxPoints = 123;

                // Build connection graph once for performance
                const connectionGraph = new Map();
                const allConnections = svg.querySelectorAll('#connections line, #connections path');
                allConnections.forEach(conn => {
                    const connId = conn.id;
                    if (connId.startsWith('c')) {
                        const parts = connId.substring(1).split('-');
                        if (parts.length === 2) {
                            const [id1, id2] = parts;
                            // Add bidirectional connections
                            if (!connectionGraph.has(id1)) connectionGraph.set(id1, []);
                            if (!connectionGraph.has(id2)) connectionGraph.set(id2, []);
                            connectionGraph.get(id1).push(id2);
                            connectionGraph.get(id2).push(id1);
                        }
                    }
                });
                // Path validation: Find shortest path to any allocated node
                function findShortestPath(targetNodeId) {

                    // If no nodes allocated, can't path (unless it's a start node)
                    if (allocatedNodes.size === 0) {
                        // Check if it's a class start node (they can be allocated freely)
                        const targetCircle = svg.querySelector(`#n${targetNodeId}`);
                        const nodeData = targetCircle?.getAttribute('data-bs-title');
                        // Class starts typically have specific names
                        if (nodeData && (nodeData.includes('RANGER') || nodeData.includes('MARAUDER') ||
                            nodeData.includes('WITCH') || nodeData.includes('DUELIST') ||
                            nodeData.includes('TEMPLAR') || nodeData.includes('SIX') ||
                            nodeData.includes('Seven'))) {
                            return [];
                        }
                        return null; // Can't allocate if nothing allocated and not a start
                    }

                    // BFS to find shortest path
                    const queue = [];
                    const visited = new Set();
                    const parent = new Map();

                    // Start from target and search for any allocated node
                    queue.push(targetNodeId);
                    visited.add(targetNodeId);

                    while (queue.length > 0) {
                        const currentId = queue.shift();

                        // If we found an allocated node, reconstruct path
                        if (allocatedNodes.has(currentId)) {
                            const path = [];
                            let node = currentId;
                            // Reconstruct path from allocated node back to target
                            while (parent.has(node)) {
                                node = parent.get(node);
                                // Add all nodes EXCEPT the already-allocated starting point
                                if (!allocatedNodes.has(node)) {
                                    path.push(node);
                                }
                            }
                            return path; // Return intermediate nodes only
                        }

                        // Find all connected nodes using pre-built graph
                        const neighbors = connectionGraph.get(currentId) || [];
                        neighbors.forEach(neighborId => {
                            if (!visited.has(neighborId)) {
                                visited.add(neighborId);
                                parent.set(neighborId, currentId);
                                queue.push(neighborId);
                            }
                        });
                    }

                    return null; // No path found
                }

                // Add zoom and pan
                let zoom = 1.0;  // Start at 1x zoom (normal size)
                let panX = 0;
                let panY = 0;
                let isDragging = false;
                let lastX = 0;
                let lastY = 0;

                // Phase 1: Update points display
                function updatePointsDisplay() {
                    const pointsUsed = allocatedNodes.size;
                    document.getElementById('points-used').textContent = pointsUsed;
                }

                function updateViewBox() {
                    // Start centered on the main tree area (from official site)
                    const baseViewBox = { x: -11326.103852910494, y: -11389.628444746082, width: 23256.18556701031, height: 20315.9793814433 };
                    const width = baseViewBox.width / zoom;
                    const height = baseViewBox.height / zoom;
                    const x = baseViewBox.x - panX / zoom;
                    const y = baseViewBox.y - panY / zoom;
                    svg.setAttribute('viewBox', `${x} ${y} ${width} ${height}`);
                }

                svg.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    lastX = e.clientX;
                    lastY = e.clientY;
                });

                svg.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const dx = e.clientX - lastX;
                        const dy = e.clientY - lastY;
                        // Multiply by a factor to make panning faster and more responsive
                        panX += dx * 50;
                        panY += dy * 50;
                        lastX = e.clientX;
                        lastY = e.clientY;
                        updateViewBox();
                    }
                });

                svg.addEventListener('mouseup', () => {
                    isDragging = false;
                });

                svg.addEventListener('mouseleave', () => {
                    isDragging = false;
                });

                svg.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? -0.1 : 0.1;  // Faster zoom
                    zoom = Math.max(0.1, Math.min(5.0, zoom + delta));
                    updateViewBox();
                });

                // Update all connection visuals
                function updateAllConnections() {
                    const allConnections = svg.querySelectorAll('#connections line, #connections path');
                    allConnections.forEach(conn => {
                        const connId = conn.id;
                        const parts = connId.replace('c', '').split('-');
                        if (parts.length === 2) {
                            const n1 = svg.querySelector(`#n${parts[0]}`);
                            const n2 = svg.querySelector(`#n${parts[1]}`);
                            if (n1 && n2 && n1.classList.contains('allocated') && n2.classList.contains('allocated')) {
                                conn.classList.add('active');
                            } else {
                                conn.classList.remove('active');
                            }
                        }
                    });
                }

                // Add click to allocate with path validation
                svg.addEventListener('click', (e) => {
                    if (e.target.tagName === 'circle') {
                        const nodeId = e.target.id.replace('n', '');

                        if (e.target.classList.contains('allocated')) {
                            // Deallocate
                            e.target.classList.remove('allocated');
                            allocatedNodes.delete(nodeId);
                        } else {
                            // Try to allocate with path finding
                            const path = findShortestPath(nodeId);

                            if (path !== null) {
                                // Allocate the target node
                                e.target.classList.add('allocated');
                                allocatedNodes.add(nodeId);

                                // Allocate all nodes in the path
                                path.forEach(pathNodeId => {
                                    const pathNode = svg.querySelector(`#n${pathNodeId}`);
                                    if (pathNode && !allocatedNodes.has(pathNodeId)) {
                                        pathNode.classList.add('allocated');
                                        allocatedNodes.add(pathNodeId);
                                    }
                                });
                            }
                        }

                        // Update points display
                        updatePointsDisplay();

                        // Update all connections
                        updateAllConnections();
                    }
                });

                // Class selection dropdown logic
                const classDropdown = document.getElementById('class-dropdown');

                classDropdown.addEventListener('change', (e) => {
                    const nodeId = e.target.value;

                    if (!nodeId) return; // No class selected

                    // Clear all allocated nodes
                    allocatedNodes.forEach(id => {
                        const node = svg.querySelector(`#n${id}`);
                        if (node) {
                            node.classList.remove('allocated');
                        }
                    });
                    allocatedNodes.clear();

                    // Clear all active connections
                    const allConnections = svg.querySelectorAll('#connections line, #connections path');
                    allConnections.forEach(conn => conn.classList.remove('active'));

                    // Allocate the selected class starting node
                    const startingNode = svg.querySelector(`#n${nodeId}`);
                    if (startingNode) {
                        startingNode.classList.add('allocated');
                        allocatedNodes.add(nodeId);
                        updatePointsDisplay();
                    }
                });

                updateViewBox();
            })
            .catch(err => {
                console.error('Failed to load SVG:', err);
                document.getElementById('tree-container').innerHTML = '<div style="color: white; padding: 20px;">Failed to load tree. Make sure poe2snippet.html exists.</div>';
            });
    </script>
</body>
</html>
